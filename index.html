<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Room Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: #808080;
            overflow: hidden;
            touch-action: none;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            position: relative;
        }
        
        canvas {
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Конфигурация комнаты
        const ROOM_SIZE = 350;
        const BORDER_SIZE = 15;
        const TOTAL_SIZE = ROOM_SIZE + BORDER_SIZE * 2;
        
        // Персонаж
        const character = {
            img: new Image(),
            x: BORDER_SIZE + (ROOM_SIZE - 64)/2, // Стартовая позиция по центру комнаты
            y: BORDER_SIZE + (ROOM_SIZE - 64)/2,
            targetX: 0,
            targetY: 0,
            speed: 0.1,
            width: 64,
            height: 64
        };
        character.img.src = 'Kop.png';

        // Настройка Canvas
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = TOTAL_SIZE * dpr;
            canvas.height = TOTAL_SIZE * dpr;
            canvas.style.width = TOTAL_SIZE + 'px';
            canvas.style.height = TOTAL_SIZE + 'px';
            ctx.scale(dpr, dpr);
            
            // Инициализация целей
            character.targetX = character.x;
            character.targetY = character.y;
        }

        // Ограничение движения в пределах комнаты
        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        function updatePosition() {
            const dx = character.targetX - character.x;
            const dy = character.targetY - character.y;
            
            character.x += dx * character.speed;
            character.y += dy * character.speed;
            
            // Границы комнаты
            const minX = BORDER_SIZE;
            const maxX = BORDER_SIZE + ROOM_SIZE - character.width;
            const minY = BORDER_SIZE;
            const maxY = BORDER_SIZE + ROOM_SIZE - character.height;
            
            character.x = clamp(character.x, minX, maxX);
            character.y = clamp(character.y, minY, maxY);
        }

        function drawRoom() {
            // Черная рамка
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, TOTAL_SIZE, TOTAL_SIZE);
            
            // Белая внутренняя часть
            ctx.fillStyle = '#FFF';
            ctx.fillRect(
                BORDER_SIZE, 
                BORDER_SIZE, 
                ROOM_SIZE, 
                ROOM_SIZE
            );
        }

        function drawCharacter() {
            ctx.drawImage(
                character.img,
                character.x,
                character.y,
                character.width,
                character.height
            );
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawRoom();
            drawCharacter();
        }

        function gameLoop() {
            updatePosition();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function handleInput(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = TOTAL_SIZE / canvas.width;
            const scaleY = TOTAL_SIZE / canvas.height;
            
            let targetX = (clientX - rect.left) * scaleX - character.width/2;
            let targetY = (clientY - rect.top) * scaleY - character.height/2;
            
            // Ограничение целей внутри комнаты
            const maxTargetX = BORDER_SIZE + ROOM_SIZE - character.width;
            const maxTargetY = BORDER_SIZE + ROOM_SIZE - character.height;
            
            character.targetX = clamp(targetX, BORDER_SIZE, maxTargetX);
            character.targetY = clamp(targetY, BORDER_SIZE, maxTargetY);
        }

        // Инициализация
        window.addEventListener('load', () => {
            setupCanvas();
            gameLoop();
            
            // Обработчики событий
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleInput(e.touches[0].clientX, e.touches[0].clientY);
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                handleInput(e.touches[0].clientX, e.touches[0].clientY);
            });

            // Для ПК
            canvas.addEventListener('click', (e) => {
                handleInput(e.clientX, e.clientY);
            });
        });

        // Ресайз окна
        window.addEventListener('resize', () => {
            setupCanvas();
        });
    </script>
</body>
</html>
